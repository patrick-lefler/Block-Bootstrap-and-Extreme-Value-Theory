---
title: "Coding the Tail: Implementing Block Bootstrap & Extreme Value Theory in R"
format:
  html: 
    theme: sandstone
    page-layout: full
    toc: true
    toc-depth: 3
    code-tools: true
    code-summary: "Display code"
    embed-resources: true
    embed-math: true
    code-fold: true
    df-print: paged
execute:
  warning: false
  message: false
---

In previous analyses, we demonstrated that standard risk models—specifically those relying on Value at Risk (VaR) calculated via the Normal distribution—fail because they assume markets follow normal, bell-shaped rules. Real markets do not. Assets like Bitcoin behave badly, exhibiting "clustering," where periods of high volatility stick together like glue, and "fat tails," where outliers occur with a frequency that defies Gaussian logic. While standard VaR might effectively manage the risk of a typical Tuesday, it is structurally blind to the Black Swan. To map the true dimensions of the cliff edge, we must turn to Extreme Value Theory (EVT), the only statistical framework explicitly designed to measure the events that "shouldn't" happen but inevitably do.

Strategic awareness of these theoretical flaws is a necessary first step, but it is insufficient for survival. Eventually, you have to stop theorizing and start running the numbers. You need a technical architecture that acknowledges the difference between a bad day and a ruinous one. You need code that doesn't panic when the data gets messy—scripts that can switch gears from calculating simple standard deviations to modeling complex, heavy-tailed distributions without breaking. This high-level project moves beyond the "why" and into the "how," providing the computational tools required to quantify the unmeasurable.


::: {.callout-note icon="false"}
## Value at Risk (VaR) vs. Extreme Value Theory (EVT): A Summary

Value at Risk (VaR) has cemented itself as the industry standard for risk reporting because it compresses complex volatility into a digestible metric. It asks a probabilistic question: "What is the maximum likely loss over a set horizon, at a 99% confidence level?" For the vast majority of trading days, this is an effective tool for setting liquidity buffers. However, VaR is structurally blind to the catastrophic. By cutting off the tail of the distribution, it treats the worst 1% of outcomes as irrelevant. It tells the risk manager where the cliff edge is located but gives no indication of how deep the drop is, often leading to a false sense of security when the market moves into "Extremistan."

Extreme Value Theory (EVT) flips this logic entirely. Instead of modeling the "average" day, EVT deliberately ignores the 99% of normal data. It isolates the outliers—the "peaks over threshold"—and fits a specialized statistical curve (the Generalized Pareto Distribution) to these rare events. This allows EVT to do what standard models cannot: extrapolate. It analyzes the geometry of past crashes to mathematically estimate the magnitude of disasters that have not yet happened. It does not assume the future will repeat the past; it assumes that tail risks follow a power law, meaning losses can scale exponentially.

The difference between the two is strategic. VaR is a measure of frequency and boundaries; it answers, "How much can we lose without it being a crisis?" It provides a comfort zone for daily operations. In contrast, EVT is a measure of severity and survival. It answers the darker question: "If the crisis hits, will we still be solvent?" VaR is designed for the mundane fluctuations of a normal market; EVT is designed for the survival of the firm during the 100-year storm.
:::


A historic dataset containing daily Bitcoin (BTC) prices from 2021 through 2025 will be used for this simple example.

### **The Setup: Preparing the Environment**

First, data is loaded, and daily log returns are calculated. Unlike the “smooth” data often used in textbooks, this dataset captures historic crypto volatility, including the drawdown periods.

```{r setup}
library(ggplot2)
library(dplyr)
library(boot)   # For Bootstrapping
library(evd)    # For Extreme Value Theory (GPD fitting)

options(scipen = 999) # display real numbers, not scientific notation

# Load the dataset
df <- read.csv("data/btc_daily_prices_2021-2025.csv")

# Format dates and sort chronologically (vital for time-series bootstrapping)
df$pricing.date <- as.Date(df$pricing.date)
df <- df[order(df$pricing.date), ]

# Calculate Daily Log Returns using log returns because they are additive over time
returns <- diff(log(df$close.price))

# Quick inspection of the "left tail" (max losses)
print(summary(returns))
```

### **Method 1: The Block Bootstrap**

Standard bootstrapping (shuffling data randomly) destroys the element of time. In crypto, bad days flock together. If Tuesday was a crash, Wednesday is likely to be volatile. If you shuffle the days randomly, you destroy this “autocorrelation” and underestimate the risk of a sustained drawdown.

To fix this, we use the Block Bootstrap. We sample *blocks* of consecutive days (e.g., 20-day chunks) rather than single days. This preserves the “memory” of the market.

::: {.callout-note icon="false"}
## Standard Bootstrapping vs. Block Bootstrapping: A Functional Distinction

Standard Bootstrapping is built on the assumption of independence. Imagine your data as a deck of cards; standard bootstrapping shuffles the deck completely before drawing a hand. It assumes that the value of one data point has no relationship to the one preceding it. This makes it the ideal tool for cross-sectional data—such as medical drug trials, customer satisfaction surveys, or manufacturing quality control—where the order of data collection is irrelevant. However, if applied to time-series data, standard bootstrapping fails catastrophically because it destroys the chronological structure, effectively erasing the "memory" of the system.

Block Bootstrapping is designed specifically for time-series data where history matters. In financial markets, weather patterns, and supply chains, data is "autocorrelated"—volatility clusters together, meaning bad days tend to follow bad days. Block bootstrapping solves this by sampling consecutive chunks (or "blocks") of data rather than single points. By keeping sequences like "Monday through Friday" intact, it preserves the temporal structure of the risk. This makes it the superior choice for calculating Value at Risk (VaR) or stress-testing portfolios, where the danger lies not just in the magnitude of a single loss, but in the sustained duration of a drawdown.

:::

```{r}
# Define the statistic we want to measure: 99% Value at Risk (VaR)
# VaR is the threshold where losses exceed this value only 1% of the time
var_stat <- function(data, indices) {
  d <- data[indices]
  return(quantile(d, 0.01)) # 1st percentile (negative return)
}

# Run the Block Bootstrap
# 'R' = 10,000 resamples (alternative histories)
# 'l' = 20 (we keep 20 consecutive days together to preserve volatility clusters)
set.seed(42)
boot_results <- tsboot(tseries = returns, 
                       statistic = var_stat, 
                       R = 10000, 
                       l = 20, 
                       sim = "fixed")

# Extract the bootstrapped VaR values
boot_vars <- data.frame(VaR = boot_results$t)

# Compare with the Standard Normal VaR (Gaussian assumption)
mean_return <- mean(returns)
std_dev <- sd(returns)
normal_var <- qnorm(0.01, mean = mean_return, sd = std_dev)

print(paste("Normal VaR (99%):", round(normal_var, 4)))
print(paste("Bootstrap VaR (99%):", round(mean(boot_vars$VaR), 4)))

```

**The Results** When applied to the dataset, the difference is stark:

-   **Normal Prediction:** -7.09%

-   **Block Bootstrap Prediction:** -8.74%

The Gaussian model predicts a loss of 7.10% on a bad day. The Bootstrap — respecting the actual texture of BTC volatility — warns you that the real number is closer to 8.75%. That 23% difference (8.74/7.09) is where bankruptcies could occur.

**Visualizing the Divergence:** The density plot below visualizes this lie. The blue line (Normal) sits comfortably to the right, while the red mass (Bootstrap) shifts ominously to the left (greater loss).

```{r}
# Visualization: The "Risk Gap" Density Plot
ggplot(boot_vars, aes(x = VaR)) +
  geom_density(fill = "#E74C3C", alpha = 0.6) +
  geom_vline(aes(xintercept = normal_var), 
             color = "blue", linetype = "dashed", linewidth = 1.2) +
  labs(title = "The Risk Gap: Block Bootstrap vs. Normal Model",
       subtitle = "Red Area = Bootstrap Prediction (Heavy Tail). Blue Line = Normal Prediction.",
       x = "99% VaR (Daily Return)",
       y = "Density") +
  theme_minimal()
```

### **Method 2: Fitting the GPD (Extreme Value Theory)**

Bootstrapping is limited to historical data. If you want to ask, “What is the probability of a crash worse than anything we have seen in the last 5 years?”, you need to utilize Extreme Value Theory (EVT).

We will use the Peaks Over Threshold (POT) method. We look only at the worst 5% of days and fit a curve specifically to them.

::: {.callout-note icon="false"}
## The Peaks Over Threshold (POT) Method: A Summary

The Peaks Over Threshold (POT) method is a specialized statistical technique designed to model extreme risks accurately. Unlike standard models that analyze every data point—diluting the signal of a crash with thousands of normal days—POT deliberately filters out the ordinary. It establishes a high "threshold" (typically the 95th percentile of losses) and analyzes only the data points that breach this line.

By isolating these outliers, POT allows analysts to fit a specific curve (the Generalized Pareto Distribution) exclusively to the "tail" of the data. This removes the noise of daily fluctuations, providing a pure mathematical model of tail behavior. It enables risk managers to extrapolate beyond historical maximums and estimate the magnitude of catastrophic events that have not yet occurred, rather than simply averaging the events that have.

:::

```{r}
# 1. Isolate the Tail (Peaks Over Threshold)
# We convert returns to losses (positive values) for the package
losses <- -returns
threshold <- quantile(losses, 0.95) # Top 5% of losses

# 2. Fit the Generalized Pareto Distribution (GPD)
fit_gpd <- fpot(losses, threshold = threshold)

# Print the Shape Parameter (xi)
# If xi > 0, it confirms a heavy tail (infinite variance potential)
print(fit_gpd$estimate)
```

**The Results:**

::: {.callout-note icon="false"}
## The Sharpe Parameter

The Shape Parameter (denoted as $\xi$ or "xi") is the single most important number generated by an Extreme Value Theory model. It acts as a precise barometer for the "heaviness" of the tail risk. Effectively, it measures how quickly the probability of a disaster fades as the event gets larger.If the parameter is zero, risk decays exponentially, implying that massive outliers are virtually impossible (the "Bell Curve" world). However, in financial markets—especially crypto—the parameter is typically positive. A positive shape parameter confirms a "heavy tail," meaning the probability of extreme loss declines very slowly. This provides mathematical proof that "unprecedented" crashes are not anomalies, but statistical certainties waiting to happen. The higher the number, the more dangerous the asset.

:::

-   Shape Parameter $\xi$: 0.061

-   Interpretation: The positive shape parameter confirms that Bitcoin’s distribution is heavy-tailed. It does not decay exponentially like a normal curve; it decays polynomially. This implies that “impossible” losses remain persistently possible.

Calculating the “Return Level”: We can now calculate the 100-Day Return Level — the loss-magnitude expected to be exceeded once every 100 days.

```{r}
# 3. Calculate the Return Level (Manual Calculation)
# We extract parameters to solve: P(X > x) = 1/Return_Period

scale_param <- fit_gpd$estimate["scale"]
shape_param <- fit_gpd$estimate["shape"]
pat <- fit_gpd$pat  # Proportion Above Threshold (how often we are in the tail)

# Define Risk Horizon: 1-in-100 days
return_period <- 100 

# The GPD Return Level Formula
return_level <- threshold + (scale_param / shape_param) * ((return_period * pat)^shape_param - 1)

print(paste("Expected 1-in-100 Day Loss (EVT):", round(return_level, 4)))

# Visualization: Tail Plot (Log Scale)
# Shows how the GPD (Line) fits the actual historical crashes (Dots)
plot(fit_gpd, which = 1) # 'which=1' usually plots Probability or Return Level
```

### **Conclusion**

By running this code on the 2021–2025 dataset, we move from abstract philosophy to concrete survival strategy. The results serve as a stark wake-up call for anyone managing capital in crypto markets.

First, the Block Bootstrap exposed the hidden danger of "volatility clustering"—the tendency for one bad day to trigger another. It revealed that standard models underestimate the 99% VaR by over 23% (predicting a -7.09% loss when the reality is -8.77%). In practical terms, that "missing" 1.7% gap is not just a statistical error; in a leveraged portfolio, it is the difference between weathering a storm and facing a liquidation event.

Second, Extreme Value Theory (EVT) provided the mathematical proof that "unprecedented" crashes are to be expected. The positive shape parameter ($\xi = 0.061$) confirms that extreme losses in Bitcoin are structural features, not temporary bugs. They are baked into the asset's DNA.

Ultimately, this analysis grants you a decisive strategic advantage. When the market inevitably breaks, you won’t be caught off guard by a Bell Curve that falsely claims the event is "impossible." You will be prepared by a GPD curve that not only told you the crash was coming but gave you the dimensions of the storm.


::: {.appendix}

##### **Session Information**

<div style="font-size: 0.8em;">
```{r}
#| echo: false

 sessionInfo() 
```
</div>


